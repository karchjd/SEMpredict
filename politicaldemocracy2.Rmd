---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: "Prediction with SEM: political democracy example"
author:
- name: MdR, JK, MF, ZB, BCP, HK
  affiliation: Leiden University, Methodology and Statistics Unit
abstract: ""
keywords: "SEM-based prediction rule example."
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
spacing: double
bibliography: ~/surfdrive/predictive-psychometrics/paper/predpsycho.bib
biblio-style: apsr
endnote: no
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(lavaan)
setwd("~/surfdrive/Predictive-Psychometrics/paper/SEM-Predictive Validity/versie2/Rcode")
```

# Intro

We made an R-function for the SEM based prediction rule and in this note we will analyze the \texttt{PoliticalDemocracy} data with this rule. 

```{r}
source('~/surfdrive/Predictive-Psychometrics/paper/SEM-Predictive Validity/versie2/Rcode/predicty.lavaan.R')
predicty.lavaan
```

# Data set

The political democracy data set is the leading data set in lavaan, used for many examples of SEM models.

```{r}
data(PoliticalDemocracy)
```

Let us first partition the data set in a training and test set. We use a small test test of size 10. 
```{r}
set.seed(1234)
id.test = sample(1:75, 10)
id.test
train = PoliticalDemocracy[-id.test, ]
test = PoliticalDemocracy[id.test, ]
```

Now define the SEM model as
```{r}
model <- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + a*y2 + b*y3 + c*y4
  dem65 =~ y5 + a*y6 + b*y7 + c*y8
  # regressions
  dem60 ~ ind60
  dem65 ~ ind60 + dem60
  # residual correlations
  y1 ~~ y5
  y2 ~~ y4 + y6
  y3 ~~ y7
  y4 ~~ y8
  y6 ~~ y8
'
```
and fit the model to the training set
```{r}
fit <- sem(model, data = train, meanstructure = TRUE)
```
With the fitted model we can make predictions for the test set using the new function \texttt{predicty.lavaan}. 


The code to obtain the predicted values is
```{r}
xnames = colnames(PoliticalDemocracy)[-c(5,6,7,8)]
ynames = colnames(PoliticalDemocracy)[c(5,6,7,8)]
yhat = predicty.lavaan(fit, newdata = test, xnames = xnames, ynames = ynames)
yhat
```
These predicted values can be compared to the observed values
```{r}
test[, ynames]
```
and we can compute the prediction error per variable
```{r}
colSums((test[, ynames] - yhat)^2)
```
and overall
```{r}
sum((test[, ynames] - yhat)^2)
```

The coefficients of the prediction rule can be obtained as
```{r}
get.coef = function(fit, xnames, ynames){
  Sxx = fitted(fit)$cov[xnames , xnames]
  Sxy = fitted(fit)$cov[xnames , ynames]
  mx = fitted(fit)$mean[xnames]
  my = fitted(fit)$mean[ynames]
  gamma = solve(Sxx) %*% Sxy
  alpha = my - t(gamma) %*% mx
  output = list(
    "alpha" = alpha,
    "gamma" = gamma
  )
  return(output)
}

get.coef(fit, xnames, ynames)
```

# Repeated 10 fold CV for varying models

With the following code we define four different SEM models for predicting the response variables, that are, the indicators for democracy in 1965. The first is the same model as used in the lavaan tutorial and used above. In model 2, the structural coefficient of ind60 to dem65 is left out; in Model 3 the residual correlations between dem60 and dem65 are left out; in model 4 both the structural coefficient and the residual correlations are left out. 

```{r}
model1 <- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + a*y2 + b*y3 + c*y4
  dem65 =~ y5 + a*y6 + b*y7 + c*y8
  # regressions
  dem60 ~ ind60
  dem65 ~ ind60 + dem60
  # residual correlations
  y1 ~~ y5
  y2 ~~ y4 + y6
  y3 ~~ y7
  y4 ~~ y8
  y6 ~~ y8
'

model2 <- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + a*y2 + b*y3 + c*y4
  dem65 =~ y5 + a*y6 + b*y7 + c*y8
  # regressions
  dem60 ~ ind60
  dem65 ~ dem60
  # residual correlations
  y1 ~~ y5
  y2 ~~ y4 + y6
  y3 ~~ y7
  y4 ~~ y8
  y6 ~~ y8
'

model3 <- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + a*y2 + b*y3 + c*y4
  dem65 =~ y5 + a*y6 + b*y7 + c*y8
  # regressions
  dem60 ~ ind60
  dem65 ~ ind60 + dem60
'

model4 <- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + a*y2 + b*y3 + c*y4
  dem65 =~ y5 + a*y6 + b*y7 + c*y8
  # regressions
  dem60 ~ ind60
  dem65 ~ dem60
'
```


We perform 100 repetitions of 10 fold cross validation and compare the overall prediction error of the models. We also add a simple multivariate multiple linear regression. We focus on the cross-validated prediction error. Furthermore, we look at the estimated coefficients over the 100 x 10 fitted models. 

```{r, warning = FALSE}
set.seed(1234)
repeats = 100
PE = data.frame(repetition = rep(1:repeats, each = 5), 
                model = rep(1:5, repeats), 
                pe = rep(0, 5 * repeats))

coefs1 = matrix(NA, 32, 1000)
coefs2 = matrix(NA, 32, 1000)
coefs3 = matrix(NA, 32, 1000)
coefs4 = matrix(NA, 32, 1000)
coefs5 = matrix(NA, 32, 1000)


folds = rep(1:10, length.out = 75)
t = 0
for (r in 1:repeats){
  yhat1 = yhat2 = yhat3 = yhat4 = yhat5 = matrix(NA, 75, 4)
  folds = sample(folds)
  for(k in 1:10){
    t = t + 1
    idx = which(folds == k)
    # approach 1
    fit <- sem(model1, data = PoliticalDemocracy[-idx, ], meanstructure = TRUE, warn = FALSE)
    yhat1[idx, ] = predicty.lavaan(fit, newdata = PoliticalDemocracy[idx, ], xnames = xnames, ynames = ynames)
    coefs = get.coef(fit, xnames, ynames)
    coefs1[, t] = rbind(matrix(coefs$alpha, 4, 1), matrix(coefs$gamma, 28, 1))
    
    # approach 2
    fit <- sem(model2, data = PoliticalDemocracy[-idx, ], meanstructure = TRUE, warn = FALSE)
    yhat2[idx, ] = predicty.lavaan(fit, newdata = PoliticalDemocracy[idx, ], xnames = xnames, ynames = ynames)
    coefs = get.coef(fit, xnames, ynames)
    coefs2[, t] = rbind(matrix(coefs$alpha, 4, 1), matrix(coefs$gamma, 28, 1))
    
    # approach 3
    fit <- sem(model3, data = PoliticalDemocracy[-idx, ], meanstructure = TRUE, warn = FALSE)
    yhat3[idx, ] = predicty.lavaan(fit, newdata = PoliticalDemocracy[idx, ], xnames = xnames, ynames = ynames)
    coefs = get.coef(fit, xnames, ynames)
    coefs3[, t] = rbind(matrix(coefs$alpha, 4, 1), matrix(coefs$gamma, 28, 1))
    
    # approach 4
    fit <- sem(model4, data = PoliticalDemocracy[-idx, ], meanstructure = TRUE, warn = FALSE)
    yhat4[idx, ] = predicty.lavaan(fit, newdata = PoliticalDemocracy[idx, ], xnames = xnames, ynames = ynames)
    coefs = get.coef(fit, xnames, ynames)
    coefs4[, t] = rbind(matrix(coefs$alpha, 4, 1), matrix(coefs$gamma, 28, 1))
    

    # linear regression model
    fit = lm(cbind(y5,y6,y7,y8) ~ ., data = PoliticalDemocracy[-idx, ])
    yhat5[idx, ]= predict(fit, newdata = PoliticalDemocracy[idx, ])
    coefs5[, t] = matrix(t(coef(fit)), 32, 1)
  }# end folds

  pe1 = sqrt(sum((PoliticalDemocracy[, ynames] - yhat1)^2)/300)
  pe2 = sqrt(sum((PoliticalDemocracy[, ynames] - yhat2)^2)/300)
  pe3 = sqrt(sum((PoliticalDemocracy[, ynames] - yhat3)^2)/300)
  pe4 = sqrt(sum((PoliticalDemocracy[, ynames] - yhat4)^2)/300)
  pe5 = sqrt(sum((PoliticalDemocracy[, ynames] - yhat5)^2)/300)
  PE$pe[((r-1)*5 + 1): (r*5)] = c(pe1, pe2, pe3, pe4, pe5)
} # end repetitions

save(PE, file = "xvalpoldem.Rdata")
save(coefs1, coefs2, coefs3, coefs4, coefs5, file = "xvalpoldemcoefs.Rdata")
```


We can make prediction error boxplots for the different approaches
```{r}
library(ggplot2)
PE$model = as.factor(PE$model)


p <- ggplot(PE, aes(x=model, y=pe, fill=factor(model))) +
      geom_boxplot(aes(group = factor(model))) + 
      geom_jitter(width = 0.05, height = 0, colour = rgb(0,0,0,.3)) + 
      xlab("Approach") + ylab("RMSEp") + 
      theme(legend.position="none") +
      scale_fill_grey(start=.3,end=.7)

p
ggsave('~/surfdrive/Predictive-Psychometrics/paper/SEM-Predictive Validity/versie2/Figures/Poldemxval.pdf', plot = p)

```

We can check the number of wins for each of the five approaches:
```{r}
pe = cbind(PE[PE$model == 1, 3], PE[PE$model == 2, 3], PE[PE$model == 3, 3], PE[PE$model == 4, 3], PE[PE$model == 5, 3])
table(apply(pe, 1, which.min))
```

Finally, we can take a look at the estimated coefficients in each of the 10 x 100 fitted models:
```{r}
coefnames = c("a5", "a6", "a7", "a8", "gy15", "gy25", "gy35", "gy45", "gx15", "gx25", "gx35", "gy16", "gy26", "gy36", "gy46", "gx16", "gx26", "gx36", "gy17", "gy27", "gy37", "gy47", "gx17", "gx27", "gx37", "gy18", "gy28", "gy38", "gy48", "gx18", "gx28", "gx38")
rownames(coefs1) = coefnames
rownames(coefs2) = coefnames
rownames(coefs3) = coefnames
rownames(coefs4) = coefnames
rownames(coefs5) = coefnames
meancoefs = cbind(apply(coefs1, 1, mean),
      apply(coefs2, 1, mean),
      apply(coefs3, 1, mean),
      apply(coefs4, 1, mean),
      apply(coefs5, 1, mean))

meancoefs
      
stdcoefs = cbind(apply(coefs1, 1, sd),
      apply(coefs2, 1, sd),
      apply(coefs3, 1, sd),
      apply(coefs4, 1, sd),
      apply(coefs5, 1, sd))

stdcoefs
```      
      